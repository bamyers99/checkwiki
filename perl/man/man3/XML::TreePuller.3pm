.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::TreePuller 3pm"
.TH XML::TreePuller 3pm "2010-05-04" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::TreePuller \- Pull interface to work with XML document fragments
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use XML::TreePuller;
\&  
\&  $pull = XML::TreePuller\->new(location => \*(Aq/what/ever/filename.xml\*(Aq);
\&  $pull = XML::TreePuller\->new(location => \*(Aqhttp://urls.too/data.xml\*(Aq);
\&  $pull = XML::TreePuller\->new(IO => \e*FH);
\&  $pull = XML::TreePuller\->new(string => \*(Aq<xml/>\*(Aq);
\&
\&  #parse the document and return the root element
\&  #takes same arguments as new()
\&  $element = XML::TreePuller\->parse(%ARGS); 
\&
\&  $pull\->reader; #return the XML::LibXML::Reader object
\&
\&  $pull\->iterate_at(\*(Aq/xml\*(Aq, \*(Aqshort\*(Aq); #read the first part of an element
\&  $pull\->iterate_at(\*(Aq/xml\*(Aq, \*(Aqsubtree\*(Aq); #read the element and subtree
\&  
\&  while($element = $pull\->next) { }
\&  
\&  $element\->name;
\&  $element\->text; #fetch text for the element and all children
\&  $element\->attribute(\*(Aqattribute_name\*(Aq); #get attribute value
\&  $element\->attribute; #returns hashref of attributes
\&  $element\->get_elements; #return all child elements 
\&  $element\->get_elements(\*(Aqelement/path\*(Aq); #elements from path
\&  $element\->xpath(\*(Aq/xml\*(Aq); #search using a XPath
.Ve
.SH "ABOUT"
.IX Header "ABOUT"
This module implements a tree oriented \s-1XML\s0 pull processor providing fast and 
convenient unmarshalling of extremely large \s-1XML\s0 documents serially. Unmarshalling means
the module is intended to turn the \s-1XML\s0 document into datastructures, not transform it. Tree
oriented means the data is returned from the engine as a tree of data replicating the
structure of the original \s-1XML\s0 document. Pull processor means you sequentially ask
the engine for more data (the opposite of \s-1SAX\s0). This engine also supports breaking
the document into fragments so the trees are small enough to fit into \s-1RAM\s0.
.SS "Features"
.IX Subsection "Features"
.IP "High speed" 4
.IX Item "High speed"
This framework has been benchmarked to process \s-1XML\s0 between 1 meg/sec
and 70 meg/sec in real world scenarios using the high level interface.
.IP "Work with documents too big to fit into \s-1RAM\s0" 4
.IX Item "Work with documents too big to fit into RAM"
The interface is nearly identical for large documents and small documents.
.IP "High level" 4
.IX Item "High level"
The document is mapped to a high level \s-1XML\s0 element class that is easy to use.
.IP "Low level" 4
.IX Item "Low level"
If you need lower level access to the \s-1XML\s0 document you can treat the
element class as a set of arrays representing the structure of your
document or you can work with the XML::LibXML::Reader instance 
directly.
.SS "Justification"
.IX Subsection "Justification"
\&\*(L"Another \s-1XML\s0 processing scheme? Why don't you create a new template parsing framework
to go with it!?\*(R" \*(-- If I had a trillion dollars for every time I've heard this I could
bail out the \s-1US\s0 Government (as of Apr 26, 2010 that is). When I set out to create the
replacement for Parse::MediaWikiDump I started by benchmarking the performance of existing
\&\s-1XML\s0 processing frameworks (\s-1XML::SAX\s0 (all of them), XML::Parser, and higher level frameworks
such as XML::Twig). The results of my research was that there exists no very fast pull oriented
high level framework for processing \s-1XML\s0.
.PP
I set about building MediaWiki::DumpFile using a base of XML::LibXML::Reader and
XML::CompactTree; I wound up with a reconfigurable \s-1XML\s0 processing engine that I
rather liked so I decided to publish it on \s-1CPAN\s0.
.SH "STATUS"
.IX Header "STATUS"
This software is currently \s-1ALPHA\s0 quality \- the only known use is
MediaWiki::DumpFile which is itself becoming tested in production. The
\&\s-1API\s0 is not stable and there may be bugs: please report success and
failure to the author below.
.SH "XML::TreePuller"
.IX Header "XML::TreePuller"
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "new" 4
.IX Item "new"
The constructor for this class returns an instance of itself; all arguments are passed
straight on to XML::LibXML::Reader when it is constructed. See the documentation for
a full specification of what you can use but for quick reference:
.RS 4
.IP "new(location => '/what/ever/filename.xml');" 4
.IX Item "new(location => '/what/ever/filename.xml');"
.PD 0
.IP "new(location => 'http://urls.work.too/data.xml');" 4
.IX Item "new(location => 'http://urls.work.too/data.xml');"
.ie n .IP "new(string => $xml_data);" 4
.el .IP "new(string => \f(CW$xml_data\fR);" 4
.IX Item "new(string => $xml_data);"
.IP "new(\s-1IO\s0 => \e*FH);" 4
.IX Item "new(IO => *FH);"
.RE
.RS 4
.RE
.IP "parse" 4
.IX Item "parse"
.PD
This method takes the same arguments as \fInew()\fR but parses the entire document into
an element and returns it; you can use this if you don't need to break the document
into chunks.
.IP "iterate_at" 4
.IX Item "iterate_at"
This method allows you to control the configuration of the processing engine; you specify
two arguments: a path to an \s-1XML\s0 element and an instruction. The engine will move along
node by node through the document and keep track of the full path to the current element. 
The combination of the current path of the \s-1XML\s0 document in the reader and the instruction
to use will cause instances of XML::TreePuller::Element to be available from the \*(L"next\*(R" method.
.Sp
If \fIiterate_at()\fR is never called then the entire document will be read into a single element
at the first invocation of \fInext()\fR.
.RS 4
.IP "iterate_at('/path/to/element' => 'short');" 4
.IX Item "iterate_at('/path/to/element' => 'short');"
When the path of the current \s-1XML\s0 element matches the path specified the 
\&\*(L"next\*(R" method will return an instance of XML::TreePuller::Element that
holds any attributes and will contain textual data up to the start
of another element; there will be no child elements in this element.
.IP "iterate_at('/ditto' => 'subtree');" 4
.IX Item "iterate_at('/ditto' => 'subtree');"
When the path of the current \s-1XML\s0 element matches the path specified the
\&\*(L"next\*(R" method will return an instance of XML::TreePuller::Element that 
holds the attributes for the element and all of the element textual data
and child elements.
.RE
.RS 4
.RE
.IP "next" 4
.IX Item "next"
This method is the iterator for the processing system. Each time an instruction is
matched it will return an instance of XML::TreePuller::Element. When called in
scalar context returns a reference to the next available element or undef when
no more data is available. When called in list context it returns a two item
list with the first item being the path to the node that was matched and the
second item being the next available element; returns an empty list when 
there is no more data to be processed.
.Sp
The returned path will always be a full path in the document starting at the
root element and ending in the element that ultimately matched.
.IP "reader" 4
.IX Item "reader"
Returns the instance of XML::LibXML::Reader that we are using to parse the
\&\s-1XML\s0 document. You can move the cursor of the reader if you want but keep this in mind:
if you move the cursor of the reader to an element in the document that is at a higher
level than the reader was sitting at when you moved it then the reader must move the
cursor to an element that was at the same depth in the document as it was at the start;
this may cause some parts of the document to be thrown out that you are not expecting.
.SH "XML::TreePuller::Element"
.IX Header "XML::TreePuller::Element"
This class is how you access the data from XML::TreePuller. XML::TreePuller::Element is 
implemented as a set of methods that operate on arrays as returned by XML::CompactTree; 
you are free to work with XML::TreePuller::Element objects just as you would work with
data returned from \fIXML::CompactTree::readSubtreeToPerl()\fR and such.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "name" 4
.IX Item "name"
Returns the name of the element as a string
.IP "text" 4
.IX Item "text"
Returns the text stored in the element and all subelements as a string; 
returns an empty string if there is no text
.IP "attribute" 4
.IX Item "attribute"
If called with out any arguments returns a hash reference containing the
attribute names as keys and the attribute values as the data. If called with
an argument returns the value for the attribute by that name or undef
if there is no attribute by that name.
.IP "get_elements" 4
.IX Item "get_elements"
Searches this element for any child elements as matched by the path supplied as
an argument; the path is relative to the current element. 
The path is of the format 'element1/element2/element3' where each element name
is seperated by a forward slash and there is no trailing or leading forwardslashes. 
If no path is specified it returns all of the child elements for the current element.
.Sp
If called in scalar context returns the first element that matches the path; if 
called in array context returns a list of all elements that matched.
.IP "xpath" 4
.IX Item "xpath"
Perform an XPath query on the element and return the results; if called in list
context you'll get all of the elements that matched. If called in scalar context
you'll get the first element that matched. XPath support is currently \s-1EXPERIMENTAL\s0.
.Sp
The XPath query is rooted at the element so you must include the current element 
name as part of the path if you are specifying an absolute path to a subelement.
.SH "IMPROVING PERFORMANCE"
.IX Header "IMPROVING PERFORMANCE"
First of all if you want to improve the throughput of this \s-1XML\s0 processing system
be sure to install XML::CompactTree::XS \- once installed this module is used
automatically and drastically improves overall performance of unmarshalling the
\&\s-1XML\s0 from the document (this does not involve XML::TreePuller::Element).
.PP
Secondly there are a number of ways to solve problems with this module, see
XML::TreePuller::CookBook::Performance for information.
.SH "FURTHER READING"
.IX Header "FURTHER READING"
.IP "XML::TreePuller::CookBook::Intro" 4
.IX Item "XML::TreePuller::CookBook::Intro"
Gentle introduction to parsing using Atom as an example.
.IP "XML::TreePuller::CookBook::Performance" 4
.IX Item "XML::TreePuller::CookBook::Performance"
High performance processing of Wikipedia dump files.
.IP "XML::TreePuller::CookBook::Patterns" 4
.IX Item "XML::TreePuller::CookBook::Patterns"
.PD 0
.IP "XPath Tutorial" 4
.IX Item "XPath Tutorial"
.RS 4
.IP "\(bu" 4
.PD
http://www.zvon.org/xxl/XPathTutorial/Output/example1.html
.IP "\(bu" 4
http://www.w3schools.com/xpath/
.RE
.RS 4
.RE
.IP "MediaWiki::DumpFile::Pages" 4
.IX Item "MediaWiki::DumpFile::Pages"
Object oriented recursive descent parser that maps Mediawiki \s-1XML\s0 dump files into
high level Perl objects for working with the data.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
.IP "\(bu" 4
This module is not \s-1XML\s0 compliant though it is built from \s-1XML\s0 compliant 
components. There may be unexpected behavior compared to proper \s-1XML\s0
behavior and if this is encountered please open a bug report.
.IP "\(bu" 4
XPath support is \s-1EXPERIMENTAL\s0 (even more so than the rest of this module)
.IP "\(bu" 4
There is only support for elements, text in elements, and \s-1CDATA\s0 blocks \- other features
of \s-1XML\s0 are not part of the \s-1API\s0 and are not tested but may bleed through from the underlying
modules used to build this system. If you have an idea on how to add support for these
extra features the author is soliciting feedback and patches.
.IP "\(bu" 4
Things are pretty arbitrary right now as this module started life as the heart of 
MediaWiki::DumpFile; it would be nice to bring in more formal \s-1XML\s0 processing 
concepts.
.SH "ATTRIBUTION"
.IX Header "ATTRIBUTION"
With out the following people this module would not be possible:
.IP "Andrew Rodland" 4
.IX Item "Andrew Rodland"
My Perl mentor and friend, his influence has helped me everywhere.
.IP "Petr Pajas" 4
.IX Item "Petr Pajas"
As the maintainer of XML::LibXML and creator of XML::CompactTree this
module would not be possible with out building on his great work.
.IP "Michel Rodriguez" 4
.IX Item "Michel Rodriguez"
For creating Tree::XPathEngine which made adding XPath support
a one day exercise.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tyler Riddle, \f(CW\*(C`<triddle at cpan.org>\*(C'\fR
