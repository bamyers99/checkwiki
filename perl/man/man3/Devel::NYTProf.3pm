.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Devel::NYTProf 3pm"
.TH Devel::NYTProf 3pm "2016-11-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Devel::NYTProf \- Powerful fast feature\-rich Perl source code profiler
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # profile code and write database to ./nytprof.out
\&  perl \-d:NYTProf some_perl.pl
\&
\&  # convert database into a set of html files, e.g., ./nytprof/index.html
\&  # and open a web browser on the nytprof/index.html file
\&  nytprofhtml \-\-open
\&
\&  # or into comma separated files, e.g., ./nytprof/*.csv
\&  nytprofcsv
.Ve
.PP
I give talks on profiling perl code, including a detailed look at how to use
NYTProf and how to optimize your code, every year. A video of my \s-1YAPC::NA 2014\s0
talk can be found at <http://perltv.org/v/performance\-profiling\-with\-develnytprof>
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Devel::NYTProf is a powerful, fast, feature-rich perl source code profiler.
.IP "\(bu" 4
Performs per-line statement profiling for fine detail
.IP "\(bu" 4
Performs per-subroutine statement profiling for overview
.IP "\(bu" 4
Performs per-opcode profiling for slow perl builtins
.IP "\(bu" 4
Performs per-block statement profiling (the first profiler to do so)
.IP "\(bu" 4
Accounts correctly for time spent after calls return
.IP "\(bu" 4
Performs inclusive and exclusive timing of subroutines
.IP "\(bu" 4
Subroutine times are per calling location (a powerful feature)
.IP "\(bu" 4
Can profile compile-time activity, just run-time, or just \s-1END\s0 time
.IP "\(bu" 4
Uses novel techniques for efficient profiling
.IP "\(bu" 4
Sub-microsecond (100ns) resolution on supported systems
.IP "\(bu" 4
Very fast \- the fastest statement and subroutine profilers for perl
.IP "\(bu" 4
Handles applications that fork, with no performance cost
.IP "\(bu" 4
Immune from noise caused by profiling overheads and I/O
.IP "\(bu" 4
Program being profiled can stop/start the profiler
.IP "\(bu" 4
Generates richly annotated and cross-linked html reports
.IP "\(bu" 4
Captures source code, including string evals, for stable results
.IP "\(bu" 4
Trivial to use with mod_perl \- add one line to httpd.conf
.IP "\(bu" 4
Includes an extensive test suite
.IP "\(bu" 4
Tested on very large codebases
.PP
NYTProf is effectively two profilers in one: a statement profiler, and a
subroutine profiler.
.SS "Statement Profiling"
.IX Subsection "Statement Profiling"
The statement profiler measures the time between entering one perl statement
and entering the next. Whenever execution reaches a new statement, the time
since entering the previous statement is calculated and added to the time
associated with the line of the source file that the previous statement starts on.
.PP
By default the statement profiler also determines the first line of the current
block and the first line of the current statement, and accumulates times
associated with those.
.PP
Another innovation unique to NYTProf is automatic compensation for a problem
inherent in simplistic statement-to-statement timing. Consider a statement that
calls a subroutine and then performs some other work that doesn't execute new
statements, for example:
.PP
.Vb 1
\&  foo(...) + mkdir(...);
.Ve
.PP
In all other statement profilers the time spent in remainder of the expression
(mkdir in the example) will be recorded as having been spent \fIon the last
statement executed in \fIfoo()\fI\fR! Here's another example:
.PP
.Vb 4
\&  while (<>) {
\&     ...
\&     1;
\&  }
.Ve
.PP
After the first time around the loop, any further time spent evaluating the
condition (waiting for input in this example) would be recorded as having
been spent \fIon the last statement executed in the loop\fR! (Until perl bug
#60954 is fixed this problem still applies to some loops. For more information
see <http://rt.perl.org/rt3/Ticket/Display.html?id=60954>)
.PP
NYTProf avoids these problems by intercepting the opcodes which indicate that
control is returning into some previous statement and adjusting the profile
accordingly.
.PP
The statement profiler naturally generates a lot of data which is streamed out
to a file in a very compact format. NYTProf takes care to not include the
measurement and writing overheads in the profile times (some profilers produce
\&'noisy' data due to periodic stdio flushing).
.SS "Subroutine Profiling"
.IX Subsection "Subroutine Profiling"
The subroutine profiler measures the time between entering a subroutine and
leaving it. It then increments a call count and accumulates the duration.
For each subroutine called, separate counts and durations are stored \fIfor each
location that called the subroutine\fR.
.PP
Subroutine entry is detected by intercepting the \f(CW\*(C`entersub\*(C'\fR opcode. Subroutine
exit is detected via perl's internal save stack. As a result the subroutine
profiler is both fast and robust.
.PP
\fISubroutine Recursion\fR
.IX Subsection "Subroutine Recursion"
.PP
For subroutines that recurse directly or indirectly, such as Error::try,
the inclusive time is only measured for the outer-most call.
.PP
The inclusive times of recursive calls are still measured and are accumulated
separately. Also the 'maximum recursion depth' per calling location is recorded.
.PP
\fIGoto &Subroutine\fR
.IX Subsection "Goto &Subroutine"
.PP
Perl implements a \f(CW\*(C`goto &destination\*(C'\fR as a \f(CW\*(C`return\*(C'\fR followed by a call to
\&\f(CW&destination\fR, so that's how it will appear in the report.
.PP
The \f(CW\*(C`goto\*(C'\fR will be shown with a very short time because it's effectively just
a \f(CW\*(C`return\*(C'\fR. The \f(CW&destination\fR sub will show a call \fInot\fR from the location
of the \f(CW\*(C`goto\*(C'\fR but from the location of the call to the sub that performed the \f(CW\*(C`goto\*(C'\fR.
.PP
\fI\fIaccept()\fI\fR
.IX Subsection "accept()"
.PP
The perl built-in \fIaccept()\fR function waits listening for a connection on a
socket, and so is a key part of pure-perl network service applications.
.PP
The time spent waiting for a remotely initiated connection can be relatively
high but is not relevant to the performance of the application. So the \fIaccept()\fR
function is treated as a special case. The subroutine profiler discounts the
time spent in the \fIaccept()\fR function. It does this in a way that also discounts
that time from all the callers up the call stack. The effect on the reports is
that all \fIaccept()\fR calls appear to be instant.
.PP
The \fIstatement\fR profiler still shows the time actually spent in the statement
that executed the \fIaccept()\fR call.
.SS "Application Profiling"
.IX Subsection "Application Profiling"
NYTProf records extra information in the data file to capture details that may
be useful when analyzing the performance. It also records the filename and line
ranges of all the subroutines.
.PP
NYTProf can profile applications that fork, and does so with no loss of
performance.
NYTProf detects the fork and starts writing a new profile file with the pid
appended to the filename. Since nytprofhtml only works with a single profile
file you may want to merge multiple files using nytprofmerge.
.SS "Fast Profiling"
.IX Subsection "Fast Profiling"
The NYTProf profiler is written almost entirely in C and great care has been
taken to ensure it's very efficient.
.SS "Apache Profiling"
.IX Subsection "Apache Profiling"
Just add one line near the start of your httpd.conf file:
.PP
.Vb 1
\&  PerlModule Devel::NYTProf::Apache
.Ve
.PP
By default you'll get a \fI/tmp/nytprof.$$.out\fR file for the parent process and
a \fI/tmp/nytprof.$parent.out.$$\fR file for each worker process.
.PP
NYTProf takes care to detect when control is returning back from perl to
mod_perl so time spent in mod_perl (such as waiting for the next request)
does not get allocated to the last statement executed.
.PP
Works with mod_perl 1 and 2. See Devel::NYTProf::Apache for more information.
.SH "PROFILING"
.IX Header "PROFILING"
Usually you'd load Devel::NYTProf on the command line using the perl \-d option:
.PP
.Vb 1
\&  perl \-d:NYTProf some_perl.pl
.Ve
.PP
To save typing the ':NYTProf' you could set the \s-1PERL5DB\s0 env var
.PP
.Vb 1
\&  PERL5DB=\*(Aquse Devel::NYTProf\*(Aq
.Ve
.PP
and then just perl \-d would work:
.PP
.Vb 1
\&  perl \-d some_perl.pl
.Ve
.PP
Or you can avoid the need to add the \-d option at all by using the \f(CW\*(C`PERL5OPT\*(C'\fR env var:
.PP
.Vb 1
\&  PERL5OPT=\-d:NYTProf
.Ve
.PP
That's also very handy when you can't alter the perl command line being used to
run the script you want to profile. Usually you'll want to enable the
\&\*(L"addpid=1\*(R" option to ensure any nested invocations of perl don't overwrite the profile.
.SH "NYTPROF ENVIRONMENT VARIABLE"
.IX Header "NYTPROF ENVIRONMENT VARIABLE"
The behavior of Devel::NYTProf may be modified by setting the 
environment variable \f(CW\*(C`NYTPROF\*(C'\fR.  It is possible to use this environment
variable to effect multiple setting by separating the values with a \f(CW\*(C`:\*(C'\fR.  For
example:
.PP
.Vb 1
\&  export NYTPROF=trace=2:start=init:file=/tmp/nytprof.out
.Ve
.PP
Any colon or equal characters in a value can be escaped by preceding them with
a backslash.
.SS "addpid=1"
.IX Subsection "addpid=1"
Append the current process id to the end of the filename.
.PP
This avoids concurrent, or consecutive, processes from overwriting the same file.
If a fork is detected during profiling then the child process will automatically
add the process id to the filename.
.SS "addtimestamp=1"
.IX Subsection "addtimestamp=1"
Append the current time, as integer epoch seconds, to the end of the filename.
.SS "trace=N"
.IX Subsection "trace=N"
Set trace level to N. 0 is off (the default). Higher values cause more detailed
trace output. Trace output is written to \s-1STDERR\s0 or wherever the \*(L"log=F\*(R"
option has specified.
.SS "log=F"
.IX Subsection "log=F"
Specify the name of the file that \*(L"trace=N\*(R" output should be written to.
.SS "start=..."
.IX Subsection "start=..."
Specify at which phase of program execution the profiler should be enabled:
.PP
.Vb 4
\&  start=begin \- start immediately (the default)
\&  start=init  \- start at beginning of INIT phase (after compilation/use/BEGIN)
\&  start=end   \- start at beginning of END phase
\&  start=no    \- don\*(Aqt automatically start
.Ve
.PP
The start=no option is handy if you want to explicitly control profiling
by calling \fIDB::enable_profile()\fR and \fIDB::disable_profile()\fR yourself.
See \*(L"RUN-TIME \s-1CONTROL OF PROFILING\*(R"\s0.
.PP
The start=init option is handy if you want to avoid profiling the loading and
initialization of modules.
.SS "optimize=0"
.IX Subsection "optimize=0"
Disable the perl optimizer.
.PP
By default NYTProf leaves perl's optimizer enabled.  That gives you more
accurate profile timing overall, but can lead to \fIodd\fR statement counts for
individual sets of lines. That's because the perl's peephole optimizer has
effectively rewritten the statements but you can't see what the rewritten
version looks like.
.PP
For example:
.PP
.Vb 3
\&  1     if (...) {
\&  2         return;
\&  3     }
.Ve
.PP
may be rewritten as
.PP
.Vb 1
\&  1    return if (...)
.Ve
.PP
so the profile won't show a statement count for line 2 in your source code
because the \f(CW\*(C`return\*(C'\fR was merged into the \f(CW\*(C`if\*(C'\fR statement on the preceding line.
.PP
Also 'empty' statements like \f(CW\*(C`1;\*(C'\fR are removed entirely.  Such statements are
empty because the optimizer has already removed the pointless constant in void
context. It then goes on to remove the now empty statement (in perl >= 5.13.7).
.PP
Using the \f(CW\*(C`optimize=0\*(C'\fR option disables the optimizer so you'll get lower
overall performance but more accurately assigned statement counts.
.PP
If you find any other examples of the effect of optimizer on NYTProf output
(other than performance, obviously) please let us know.
.SS "subs=0"
.IX Subsection "subs=0"
Set to 0 to disable the collection of subroutine caller and timing details.
.SS "blocks=1"
.IX Subsection "blocks=1"
Set to 1 to enable the determination of block and subroutine location per statement.
This makes the profiler about 50% slower (as of July 2008) and produces larger
output files, but you gain some valuable insight in where time is spent in the
blocks within large subroutines and scripts.
.SS "stmts=0"
.IX Subsection "stmts=0"
Set to 0 to disable the statement profiler. (Implies \f(CW\*(C`blocks=0\*(C'\fR.)
The reports won't contain any statement timing detail.
.PP
This significantly reduces the overhead of the profiler and can also be useful
for profiling large applications that would normally generate a very large
profile data file.
.SS "calls=N"
.IX Subsection "calls=N"
This option is \fInew and experimental\fR.
.PP
With calls=1 (the default) subroutine call \fIreturn\fR events are emitted into
the data stream as they happen.  With calls=2 subroutine call \fIentry\fR events
are also emitted. With calls=0 no subroutine call events are produced.
This option depends on the \f(CW\*(C`subs\*(C'\fR option being enabled, which it is by default.
.PP
The nytprofcalls utility can be used to process this data. It too is \fInew
and experimental\fR and so likely to change.
.PP
The subroutine profiler normally gathers data in memory and outputs a summary
when the profile data is being finalized, usually when the program has finished.
The summary contains aggregate information for all the calls from one location
to another, but the details of individual calls have been lost.
The calls option enables the recording of individual call events and thus
more detailed analysis and reporting of that data.
.SS "leave=0"
.IX Subsection "leave=0"
Set to 0 to disable the extra work done by the statement profiler
to allocate times accurately when
returning into the middle of statement. For example leaving a subroutine
and returning into the middle of statement, or re-evaluating a loop condition.
.PP
This feature also ensures that in embedded environments, such as mod_perl,
the last statement executed doesn't accumulate the time spent 'outside perl'.
.SS "findcaller=1"
.IX Subsection "findcaller=1"
Force NYTProf to recalculate the name of the caller of the each sub instead of
\&'inheriting' the name calculated when the caller was entered. (Rarely needed,
but might be useful in some odd cases.)
.SS "use_db_sub=1"
.IX Subsection "use_db_sub=1"
Set to 1 to enable use of the traditional \s-1\fIDB::DB\s0()\fR subroutine to perform
profiling, instead of the faster 'opcode redirection' technique that's used by
default. Also effectively sets \f(CW\*(C`leave=0\*(C'\fR (see above).
.PP
The default 'opcode redirection' technique can't profile subroutines that were
compiled before NYTProf was loaded. So using use_db_sub=1 can be useful in
cases where you can't load the profiler early in the life of the application.
.PP
Another side effect of \f(CW\*(C`use_db_sub=1\*(C'\fR is that it enables recording of the
source code of the \f(CW\*(C`perl \-e \*(Aq...\*(Aq\*(C'\fR and \f(CW\*(C`perl \-\*(C'\fR input for old
versions of perl. See also \*(L"savesrc=0\*(R".
.SS "savesrc=0"
.IX Subsection "savesrc=0"
Disable the saving of source code.
.PP
By default NYTProf saves a copy of all source code into the profile data file.
This makes the file self-contained, so the reporting tools no longer depend on
having the unmodified source code files available.
.PP
With \f(CW\*(C`savesrc=0\*(C'\fR some source code is still saved: the arguments to the
\&\f(CW\*(C`perl \-e\*(C'\fR option, the script fed to perl via \s-1STDIN\s0 when using \f(CW\*(C`perl \-\*(C'\fR,
and the source code of string evals.
.PP
Saving the source code of string evals requires perl version 5.8.9+, 5.10.1+,
or 5.12 or later.
.PP
Saving the source code of the \f(CW\*(C`perl \-e \*(Aq...\*(Aq\*(C'\fR or \f(CW\*(C`perl \-\*(C'\fR input
requires either a recent perl version, as above, or setting the \*(L"use_db_sub=1\*(R" option.
.SS "slowops=N"
.IX Subsection "slowops=N"
Profile perl opcodes that can be slow. These include opcodes that make system
calls, such as \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`socket\*(C'\fR etc., plus regular
expression opcodes like \f(CW\*(C`subst\*(C'\fR and \f(CW\*(C`match\*(C'\fR.
.PP
If \f(CW\*(C`N\*(C'\fR is 0 then slowops profiling is disabled.
.PP
If \f(CW\*(C`N\*(C'\fR is 1 then all the builtins are treated as being defined in the \f(CW\*(C`CORE\*(C'\fR
package. So times for \f(CW\*(C`print\*(C'\fR calls from anywhere in your code are merged and
accounted for as calls to an xsub called \f(CW\*(C`CORE::print\*(C'\fR.
.PP
If \f(CW\*(C`N\*(C'\fR is 2 (the default) then builtins are treated as being defined in the
package that calls them. So calls to \f(CW\*(C`print\*(C'\fR from package \f(CW\*(C`Foo\*(C'\fR are treated
as calls to an xsub called \f(CW\*(C`Foo::CORE:print\*(C'\fR. Note the single colon after \s-1CORE.\s0
.PP
The opcodes are currently profiled using their internal names, so \f(CW\*(C`printf\*(C'\fR is \f(CW\*(C`prtf\*(C'\fR
and the \f(CW\*(C`\-x\*(C'\fR file test is \f(CW\*(C`fteexec\*(C'\fR. This may change in future.
.PP
Opcodes that call subroutines, perhaps by triggering a \s-1FETCH\s0 from a tied
variable, currently appear in the call tree as the caller of the sub. This is
likely to change in future.
.SS "usecputime=1"
.IX Subsection "usecputime=1"
This option has been removed. Profiling won't be enabled if set.
.PP
Use the \*(L"clock=N\*(R" option to select a high-resolution \s-1CPU\s0 time clock, if
available on your system, instead. That will give you higher resolution and work
for the subroutine profiler as well.
.SS "file=..."
.IX Subsection "file=..."
Specify the output file to write profile data to (default: './nytprof.out').
.SS "compress=..."
.IX Subsection "compress=..."
Specify the compression level to use, if NYTProf is compiled with compression
support. Valid values are 0 to 9, with 0 disabling compression. The default is
6 as higher values yield little extra compression but the cpu cost starts to
rise significantly. Using level 1 still gives you a significant reduction in file size.
.PP
If NYTProf was not compiled with compression support, this option is silently ignored.
.SS "clock=N"
.IX Subsection "clock=N"
Systems which support the \f(CW\*(C`clock_gettime()\*(C'\fR system call typically
support several clocks. By default NYTProf uses \s-1CLOCK_MONOTONIC.\s0
.PP
This option enables you to select a different clock by specifying the
integer id of the clock (which may vary between operating system types).
If the clock you select isn't available then \s-1CLOCK_REALTIME\s0 is used.
.PP
See \*(L"\s-1CLOCKS\*(R"\s0 for more information.
.SS "sigexit=1"
.IX Subsection "sigexit=1"
When perl exits normally it runs any code defined in \f(CW\*(C`END\*(C'\fR blocks.
NYTProf defines an \s-1END\s0 block that finishes profiling and writes out the final
profile data.
.PP
If the process ends due to a signal then \s-1END\s0 blocks are not executed so the
profile will be incomplete and unusable.  The \f(CW\*(C`sigexit\*(C'\fR option tells NYTProf
to catch some signals (e.g. \s-1INT, HUP, PIPE, SEGV, BUS\s0) and ensure a usable
profile by executing:
.PP
.Vb 2
\&    DB::finish_profile();
\&    exit 1;
.Ve
.PP
You can also specify which signals to catch in this way by listing them,
separated by commas, as the value of the option (case is not significant):
.PP
.Vb 1
\&    sigexit=int,hup
.Ve
.SS "posix_exit=1"
.IX Subsection "posix_exit=1"
The NYTProf subroutine profiler normally detects calls to \f(CW\*(C`POSIX::_exit()\*(C'\fR
(which exits the process without running \s-1END\s0 blocks) and automatically calls
\&\f(CW\*(C`DB::finish_profile()\*(C'\fR for you, so NYTProf 'just works'.
.PP
When using the \f(CW\*(C`subs=0\*(C'\fR option to disable the subroutine profiler the
\&\f(CW\*(C`posix_exit\*(C'\fR option can be used to tell NYTProf to take other steps to arrange
for \f(CW\*(C`DB::finish_profile()\*(C'\fR to be called before \f(CW\*(C`POSIX::_exit()\*(C'\fR.
.SS "libcexit=1"
.IX Subsection "libcexit=1"
Arranges for \*(L"finish_profile\*(R" to be called via the C library \f(CW\*(C`atexit()\*(C'\fR function.
This may help some tricky cases where the process may exit without perl
executing the \f(CW\*(C`END\*(C'\fR block that NYTProf uses to call /\fIfinish_profile()\fR.
.SS "endatexit=1"
.IX Subsection "endatexit=1"
Sets the \s-1PERL_EXIT_DESTRUCT_END\s0 flag in the PL_exit_flags of the perl interpreter.
This makes perl run \f(CW\*(C`END\*(C'\fR blocks in \fIperl_destruct()\fR instead of \fIperl_run()\fR
which may help in cases, like Apache, where perl is embedded but \fIperl_run()\fR
isn't called.
.SS "forkdepth=N"
.IX Subsection "forkdepth=N"
When a perl process that is being profiled executes a \fIfork()\fR the child process
is also profiled. The forkdepth option can be used to control this. If
forkdepth is zero then profiling will be disabled in the child process.
.PP
If forkdepth is greater than zero then profiling will be enabled in the child
process and the forkdepth value in that process is decremented by one.
.PP
If forkdepth is \-1 (the default) then there's no limit on the number of
generations of children that are profiled.
.SS "nameevals=0"
.IX Subsection "nameevals=0"
The 'file name' of a string eval is normally a string like "\f(CW\*(C`(eval N)\*(C'\fR", where
\&\f(CW\*(C`N\*(C'\fR is a sequence number. By default NYTProf asks perl to give evals more
informative names like "\f(CW\*(C`(eval N)[file:line]\*(C'\fR", where \f(CW\*(C`file\*(C'\fR and \f(CW\*(C`line\*(C'\fR are
the file and line number where the string \f(CW\*(C`eval\*(C'\fR was executed.
.PP
The \f(CW\*(C`nameevals=0\*(C'\fR option can be used to disable the more informative names and
return to the default behaviour. This may be need in rare cases where the
application code is sensitive to the name given to a \f(CW\*(C`eval\*(C'\fR. (The most common
case in when running test suites undef NYTProf.)
.PP
The downside is that the NYTProf reporting tools are less useful and may get
confused if this option is used.
.SS "nameanonsubs=0"
.IX Subsection "nameanonsubs=0"
The name of a anonymous subroutine is normally "\f(CW\*(C`_\|_ANON_\|_\*(C'\fR\*(L".  By default
NYTProf asks perl to give anonymous subroutines more informative names like
\&\*(R"\f(CW\*(C`_\|_ANON_\|_[file:line]\*(C'\fR", where \f(CW\*(C`file\*(C'\fR and \f(CW\*(C`line\*(C'\fR are the file and line
number where the anonymous subroutine was defined.
.PP
The \f(CW\*(C`nameanonsubs=0\*(C'\fR option can be used to disable the more informative names
and return to the default behaviour. This may be need in rare cases where the
application code is sensitive to the name given to a anonymous subroutines.
(The most common case in when running test suites undef NYTProf.)
.PP
The downside is that the NYTProf reporting tools are less useful and may get
confused if this option is used.
.SH "RUN-TIME CONTROL OF PROFILING"
.IX Header "RUN-TIME CONTROL OF PROFILING"
You can profile only parts of an application by calling \fIDB::disable_profile()\fR
to stop collecting profile data, and calling \fIDB::enable_profile()\fR to start
collecting profile data.
.PP
Using the \f(CW\*(C`start=no\*(C'\fR option lets you leave the profiler disabled initially
until you call \fIDB::enable_profile()\fR at the right moment. You still need to
load Devel::NYTProf as early as possible, even if you don't call
\&\fIDB::enable_profile()\fR until much later. That's because any code that's compiled
before Devel::NYTProf is loaded will not be profiled by default. See also
\&\*(L"use_db_sub=1\*(R".
.PP
The profile output file can't be used until it's been properly completed and
closed.  Calling \fIDB::disable_profile()\fR doesn't do that.  To make a profile file
usable before the profiled application has completed you can call
\&\fIDB::finish_profile()\fR. Alternatively you could call DB::enable_profile($newfile).
.PP
Always call the \fIDB::enable_profile()\fR, \fIDB::disable_profile()\fR or
\&\fIDB::finish_profile()\fR function with the \f(CW\*(C`DB::\*(C'\fR prefix as shown because you
can't import them. They're provided automatically when NYTProf is in use.
.SS "disable_profile"
.IX Subsection "disable_profile"
.Vb 1
\&  DB::disable_profile()
.Ve
.PP
Stops collection of profile data until \fIDB:enable_profile()\fR is called.
.PP
Subroutine calls which were made while profiling was enabled and are still on
the call stack (have not yet exited) will still have their profile data
collected when they exit. Compare with \*(L"finish_profile\*(R" below.
.SS "enable_profile"
.IX Subsection "enable_profile"
.Vb 2
\&  DB::enable_profile($newfile)
\&  DB::enable_profile()
.Ve
.PP
Enables collection of profile data. If \f(CW$newfile\fR is specified the profile data will be
written to \f(CW$newfile\fR (after completing and closing the previous file, if any).
If \f(CW$newfile\fR already exists it will be deleted first.
If \fIDB::enable_profile()\fR is called without a filename argument then profile data
will continue to be written to the current file (nytprof.out by default).
.SS "finish_profile"
.IX Subsection "finish_profile"
.Vb 1
\&  DB::finish_profile()
.Ve
.PP
Calls \fIDB::disable_profile()\fR, then completes the profile data file by writing
subroutine profile data, and then closes the file. The in memory subroutine
profile data is then discarded.
.PP
Normally NYTProf arranges to call \fIfinish_profile()\fR for you via an \s-1END\s0 block.
.SH "DATA COLLECTION AND INTERPRETATION"
.IX Header "DATA COLLECTION AND INTERPRETATION"
NYTProf tries very hard to gather accurate information.  The nature of the
internals of perl mean that, in some cases, the information that's gathered is
accurate but surprising. In some cases it can appear to be misleading.
(Of course, in some cases it may actually be plain wrong. Caveat lector.)
.SS "If Statement and Subroutine Timings Don't Match"
.IX Subsection "If Statement and Subroutine Timings Don't Match"
NYTProf has two profilers: a statement profiler that's invoked when perl moves
from one perl statement to another, and a subroutine profiler that's invoked
when perl calls or returns from a subroutine.
.PP
The individual statement timings for a subroutine usually add up to slightly
less than the exclusive time for the subroutine. That's because the handling of
the subroutine call and return overheads is included in the exclusive time for
the subroutine. The difference may only be a few microseconds but that may
become noticeable for subroutines that are called hundreds of thousands of times.
.PP
The statement profiler keeps track how much time was spent on overheads, like
writing statement profile data to disk. The subroutine profiler subtracts the
overheads that have accumulated between entering and leaving the subroutine in
order to give a more accurate profile.  The statement profiler is generally
very fast because most writes get buffered for zip compression so the profiler
overhead per statement tends to be very small, often a single 'tick'.
The result is that the accumulated overhead is quite noisy. This becomes more
significant for subroutines that are called frequently and are also fast.
This may be another, smaller, contribution to the discrepancy between statement
time and exclusive times.
.SS "If Headline Subroutine Timings Don't Match the Called Subs"
.IX Subsection "If Headline Subroutine Timings Don't Match the Called Subs"
Overall subroutine times are reported with a headline like \f(CW\*(C`spent 10s (2+8) within ...\*(C'\fR.
In this example, 10 seconds were spent inside the subroutine (the \*(L"inclusive
time\*(R") and, of that, 8 seconds were spent in subroutines called by this one.
That leaves 2 seconds as the time spent in the subroutine code itself (the
\&\*(L"exclusive time\*(R", sometimes also called the \*(L"self time\*(R").
.PP
The report shows the source code of the subroutine. Lines that make calls to
other subroutines are annotated with details of the time spent in those calls.
.PP
Sometimes the sum of the times for calls made by the lines of code in the
subroutine is less than the inclusive-exclusive time reported in the headline
(10\-2 = 8 seconds in the example above).
.PP
What's happening here is that calls to other subroutines are being made but
NYTProf isn't able to determine the calling location correctly so the calls
don't appear in the report in the correct place.
.PP
Using an old version of perl is one cause (see below). Another is calling
subroutines that exit via \f(CW\*(C`goto &sub;\*(C'\fR \- most frequently encountered in
\&\s-1AUTOLOAD\s0 subs and code using the Memoize module.
.PP
In general the overall subroutine timing is accurate and should be trusted more
than the sum of statement or nested sub call timings.
.SS "Perl 5.10.1+ (or else 5.8.9+) is Recommended"
.IX Subsection "Perl 5.10.1+ (or else 5.8.9+) is Recommended"
These versions of perl yield much more detailed information about calls to
\&\s-1BEGIN, CHECK, INIT,\s0 and \s-1END\s0 blocks, the code handling tied or overloaded
variables, and callbacks from \s-1XS\s0 code.
.PP
Perl 5.12 will hopefully also fix an inaccuracy in the timing of the last
statement and the condition clause of some kinds of loops:
<http://rt.perl.org/rt3/Ticket/Display.html?id=60954>
.ie n .SS "eval $string"
.el .SS "eval \f(CW$string\fP"
.IX Subsection "eval $string"
Perl treats each execution of a string eval (\f(CW\*(C`eval $string;\*(C'\fR not \f(CW\*(C`eval { ...  }\*(C'\fR)
as a distinct file, so NYTProf does as well. The 'files' are given names with
this structure:
.PP
.Vb 1
\&        (eval $sequence)[$filename:$line]
.Ve
.PP
for example "\f(CW\*(C`(eval 93)[/foo/bar.pm:42]\*(C'\fR\*(L" would be the name given to the
93rd execution of a string eval by that process and, in this case, the 93rd
eval happened to be one at line 42 of \*(R"/foo/bar.pm".
.PP
Nested string evals can give rise to file names like
.PP
.Vb 1
\&        (eval 1047)[(eval 93)[/foo/bar.pm:42]:17]
.Ve
.PP
\fIMerging Evals\fR
.IX Subsection "Merging Evals"
.PP
Some applications execute a great many string eval statements. If NYTProf generated
a report page for each one it would not only slow report generation but also
make the overall report less useful by scattering performance data too widely.
On the other hand, being able to see the actual source code executed by an
eval, along with the timing details, is often \fIvery\fR useful.
.PP
To try to balance these conflicting needs, NYTProf currently \fImerges
uninteresting string eval siblings\fR.
.PP
What does that mean? Well, for each source code line that executed any string
evals, NYTProf first gathers the corresponding eval 'files' for that line
(known as the 'siblings') into groups keyed by distinct source code.
.PP
Then, for each of those groups of siblings, NYTProf will 'merge' a group
that shares the same source code and doesn't execute any string evals itself.
Merging means to pick one sibling as the survivor and merge and delete all
the data from the others into it.
.PP
If there are a large number of sibling groups then the data for all of them are
merged into one regardless.
.PP
The report annotations will indicate when evals have been merged together.
.PP
\fIMerging Anonymous Subroutines\fR
.IX Subsection "Merging Anonymous Subroutines"
.PP
Anonymous subroutines defined within string evals have names like this:
.PP
.Vb 1
\&        main::_\|_ANON_\|_[(eval 75)[/foo/bar.pm:42]:12]
.Ve
.PP
That anonymous subroutine was defined on line 12 of the source code executed by
the string eval on line 42 of \fI/foo/bar.pm\fR. That was the 75th string eval
executed by the program.
.PP
Anonymous subroutines \fIdefined on the same line of sibling evals that get
merged\fR are also merged. That is, the profile information is merged into
one and the others are discarded.
.PP
\fITiming\fR
.IX Subsection "Timing"
.PP
Care should be taken when interpreting the report annotations associated with a
string eval statement.  Normally the report annotations embedded into the
source code related to timings from the \fIsubroutine\fR profiler. This isn't
(currently) true of annotations for string eval statements.
.PP
This makes a significant different if the eval defines any subroutines that get
called \fIafter\fR the eval has returned. Because the time shown for a string eval
is based on the \fIstatement\fR times it will include time spent executing
statements within the subs defined by the eval.
.PP
In future NYTProf may involve the subroutine profiler in timings evals and so
be able to avoid this issue.
.SS "Calls from XSUBs and Opcodes"
.IX Subsection "Calls from XSUBs and Opcodes"
Calls record the current filename and line number of the perl code at the time
the call was made. That's fine and accurate for calls from perl code. For calls
that originate from C code however, such as an \s-1XSUB\s0 or an opcode, the filename and
line number recorded are still those of the last \fIperl\fR statement executed.
.PP
For example, a line that calls an xsub will appear in reports to also have also
called any subroutines that that xsub called. This can be construed as a feature.
.PP
As an extreme example, the first time a regular expression that uses character
classes is executed on a unicode string you'll find profile data like this:
.PP
.Vb 6
\&      # spent 1ms within main::BEGIN@4 which was called
\&      #    once (1ms+0s) by main::CORE:subst at line 0
\&  4   s/ (?: [A\-Z] | [\ed] )+ (?= [\es] ) //x;
\&      # spent  38.8ms making 1 call to main::CORE:subst
\&      # spent  25.4ms making 2 calls to utf8::SWASHNEW, avg 12.7ms/call
\&      # spent  12.4ms making 1 call to utf8::AUTOLOAD
.Ve
.SH "MAKING NYTPROF FASTER"
.IX Header "MAKING NYTPROF FASTER"
You can reduce the cost of profiling by adjusting some options. The trade-off
is reduced detail and/or accuracy in reports.
.PP
If you don't need statement-level profiling then you can disable it via \*(L"stmts=0\*(R".
To further boost statement-level profiling performance try \*(L"leave=0\*(R" but note that
\&\fIwill\fR apportion timings for some kinds of statements less accurate).
.PP
If you don't need call stacks or flamegraph then disable it via \*(L"calls=0\*(R".
If you don't need subroutine profiling then you can disable it via \*(L"subs=0\*(R".
If you do need it but don't need timings for perl opcodes then set \*(L"slowops=0\*(R".
.PP
Generally speaking, setting calls=0 and slowops=0 will give you a useful boost
with the least loss of detail.
.PP
Another approach is to only enable NYTProf in the sections of code that
interest you. See \*(L"RUN-TIME \s-1CONTROL OF PROFILING\*(R"\s0 for more details.
.PP
To speed up nytprofhtml try using the \-\-minimal (\-m) or \-\-no\-flame options.
.SH "REPORTS"
.IX Header "REPORTS"
The Devel::NYTProf::Data module provides a low-level interface for loading
the profile data.
.PP
The Devel::NYTProf::Reader module provides an interface for generating
arbitrary reports.  This means that you can implement your own output format in
perl. (Though the module is in a state of flux and may be deprecated soon.)
.PP
Included in the bin directory of this distribution are some scripts which
turn the raw profile data into more useful formats:
.SS "nytprofhtml"
.IX Subsection "nytprofhtml"
Creates attractive, richly annotated, and fully cross-linked html
reports (including statistics, source code and color highlighting).
This is the main report generation tool for NYTProf.
.SS "nytprofcg"
.IX Subsection "nytprofcg"
Translates a profile into a format that can be loaded into KCachegrind
<http://kcachegrind.github.io/>
.SS "nytprofcalls"
.IX Subsection "nytprofcalls"
Reads a profile and processes the calls events it contains.
.SS "nytprofmerge"
.IX Subsection "nytprofmerge"
Reads multiple profile data files and writes out a new file containing the merged profile data.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
.SS "Threads and Multiplicity"
.IX Subsection "Threads and Multiplicity"
\&\f(CW\*(C`Devel::NYTProf\*(C'\fR is not currently thread safe or multiplicity safe.
If you'd be interested in helping to fix that then please get in
touch with us. Meanwhile, profiling is disabled when a thread is created, and
NYTProf tries to ignore any activity from perl interpreters other than the
first one that loaded it.
.SS "Coro"
.IX Subsection "Coro"
The \f(CW\*(C`Devel::NYTProf\*(C'\fR subroutine profiler gets confused by the stack gymnastics
performed by the Coro module and aborts. When profiling applications that
use Coro you should disable the subroutine profiler using the \*(L"subs=0\*(R" option.
.SS "FCGI::Engine"
.IX Subsection "FCGI::Engine"
Using \f(CW\*(C`open(\*(Aq\-|\*(Aq)\*(C'\fR in code running under FCGI::Engine causes a panic in nytprofcalls.
See https://github.com/timbunce/devel\-nytprof/issues/20 for more information.
.SS "For perl < 5.8.8 it may change what \fIcaller()\fP returns"
.IX Subsection "For perl < 5.8.8 it may change what caller() returns"
For example, the Readonly module croaks with \*(L"Invalid tie\*(R" when profiled with
perl versions before 5.8.8. That's because Readonly explicitly checking for
certain values from \fIcaller()\fR. The \s-1NEXT\s0 module is also affected.
.SS "For perl < 5.10.1 it can't see some implicit calls and callbacks"
.IX Subsection "For perl < 5.10.1 it can't see some implicit calls and callbacks"
For perl versions prior to 5.8.9 and 5.10.1, some implicit subroutine calls
can't be seen by the \fIsubroutine\fR profiler. Technically this affects calls
made via the various perl \f(CW\*(C`call_*()\*(C'\fR internal APIs.
.PP
For example, \s-1BEGIN/CHECK/INIT/END\s0 blocks, the \f(CW\*(C`TIE\*(C'\fR\fIwhatever\fR subroutine
called by \f(CW\*(C`tie()\*(C'\fR, all calls made via operator overloading, and callbacks from
\&\s-1XS\s0 code, are not seen.
.PP
The effect is that time in those subroutines is accumulated by the
subs that triggered the call to them. So time spent in calls invoked by
perl to handle overloading are accumulated by the subroutines that trigger
overloading (so it is measured, but the cost is dispersed across possibly many
calling locations).
.PP
Although the calls aren't seen by the subroutine profiler, the individual
\&\fIstatements\fR executed by the code in the called subs are profiled by the
statement profiler.
.SS "#line directives"
.IX Subsection "#line directives"
The reporting code currently doesn't handle #line directives, but at least it
warns about them. Patches welcome.
.ie n .SS "Freed values in @_ may be mutated"
.el .SS "Freed values in \f(CW@_\fP may be mutated"
.IX Subsection "Freed values in @_ may be mutated"
Perl has a class of bugs related to the fact that values placed in the stack
are not reference counted. Consider this example:
.PP
.Vb 1
\&  @a = (1..9);  sub s { undef @a; print $_ for @_ }  s(@a);
.Ve
.PP
The \f(CW\*(C`undef @a\*(C'\fR frees the values that \f(CW@_\fR refers to. Perl can sometimes
detect when a freed value is accessed and treats it as an undef. However, if
the freed value is assigned some new value then \f(CW@_\fR is effectively corrupted.
.PP
NYTProf allocates new values while it's profiling, in order to record program
activity, and so may appear to corrupt \f(CW@_\fR in this (rare) situation.  If this
happens, NYTProf is simply exposing an existing problem in the code.
.SS "Lvalue subroutines aren't profiled when using use_db_sub=1"
.IX Subsection "Lvalue subroutines aren't profiled when using use_db_sub=1"
Currently 'lvalue' subroutines (subs that can be assigned to, like \f(CW\*(C`foo() =
42\*(C'\fR) are not profiled when using use_db_sub=1.
.SH "CLOCKS"
.IX Header "CLOCKS"
Here we discuss the way NYTProf gets high-resolution timing information from
your system and related issues.
.SS "\s-1POSIX\s0 Clocks"
.IX Subsection "POSIX Clocks"
These are the clocks that your system may support if it supports the \s-1POSIX
\&\s0\f(CW\*(C`clock_gettime()\*(C'\fR function. Other clock sources are listed in the
\&\*(L"Other Clocks\*(R" section below.
.PP
The \f(CW\*(C`clock_gettime()\*(C'\fR interface allows clocks to return times to nanosecond
precision. Of course few offer nanosecond \fIaccuracy\fR but the extra precision
helps reduce the cumulative error that naturally occurs when adding together
many timings. When using these clocks NYTProf outputs timings as a count of 100
nanosecond ticks.
.PP
\fI\s-1CLOCK_MONOTONIC\s0\fR
.IX Subsection "CLOCK_MONOTONIC"
.PP
\&\s-1CLOCK_MONOTONIC\s0 represents the amount of time since an unspecified point in
the past (typically system start-up time).  It increments uniformly
independent of adjustments to 'wallclock time'. NYTProf will use this clock by
default, if available.
.PP
\fI\s-1CLOCK_REALTIME\s0\fR
.IX Subsection "CLOCK_REALTIME"
.PP
\&\s-1CLOCK_REALTIME\s0 is typically the system's main high resolution 'wall clock time'
source.  The same source as used for the \fIgettimeofday()\fR call used by most kinds
of perl benchmarking and profiling tools.
.PP
The problem with real time is that it's far from simple. It tends to drift and
then be reset to match 'reality', either sharply or by small adjustments (via the
\&\fIadjtime()\fR system call).
.PP
Surprisingly, it can also go backwards, for reasons explained in
http://preview.tinyurl.com/5wawnn so \s-1CLOCK_MONOTONIC\s0 is preferred.
.PP
\fI\s-1CLOCK_VIRTUAL\s0\fR
.IX Subsection "CLOCK_VIRTUAL"
.PP
\&\s-1CLOCK_VIRTUAL\s0 increments only when the \s-1CPU\s0 is running in user mode on behalf of the calling process.
.PP
\fI\s-1CLOCK_PROF\s0\fR
.IX Subsection "CLOCK_PROF"
.PP
\&\s-1CLOCK_PROF\s0 increments when the \s-1CPU\s0 is running in user \fIor\fR kernel mode.
.PP
\fI\s-1CLOCK_PROCESS_CPUTIME_ID\s0\fR
.IX Subsection "CLOCK_PROCESS_CPUTIME_ID"
.PP
\&\s-1CLOCK_PROCESS_CPUTIME_ID\s0 represents the amount of execution time of the process associated with the clock.
.PP
\fI\s-1CLOCK_THREAD_CPUTIME_ID\s0\fR
.IX Subsection "CLOCK_THREAD_CPUTIME_ID"
.PP
\&\s-1CLOCK_THREAD_CPUTIME_ID\s0 represents the amount of execution time of the thread associated with the clock.
.PP
\fIFinding Available \s-1POSIX\s0 Clocks\fR
.IX Subsection "Finding Available POSIX Clocks"
.PP
On unix-like systems you can find the CLOCK_* clocks available on you system
using a command like:
.PP
.Vb 1
\&  grep \-r \*(Aqdefine *CLOCK_\*(Aq /usr/include
.Ve
.PP
Look for a group that includes \s-1CLOCK_REALTIME.\s0 The integer values listed are
the clock ids that you can use with the \f(CW\*(C`clock=N\*(C'\fR option.
.PP
A future version of NYTProf should be able to list the supported clocks.
.SS "Other Clocks"
.IX Subsection "Other Clocks"
This section lists other clock sources that NYTProf may use.
.PP
If your system doesn't support \fIclock_gettime()\fR then NYTProf will use
\&\fIgettimeofday()\fR, or the nearest equivalent,
.PP
\fIgettimeofday\fR
.IX Subsection "gettimeofday"
.PP
This is the traditional high resolution time of day interface for most
unix-like systems.  With this clock NYTProf outputs timings as a count of 1
microsecond ticks.
.PP
\fImach_absolute_time\fR
.IX Subsection "mach_absolute_time"
.PP
On Mac \s-1OS X\s0 the \fImach_absolute_time()\fR function is used. With this clock NYTProf
outputs timings as a count of 100 nanosecond ticks.
.PP
\fITime::HiRes\fR
.IX Subsection "Time::HiRes"
.PP
On systems which don't support other clocks, NYTProf falls back to using the
Time::HiRes module.  With this clock NYTProf outputs timings as a count of 1
microsecond ticks.
.SS "Clock References"
.IX Subsection "Clock References"
Relevant specifications and manual pages:
.PP
.Vb 2
\&  http://www.opengroup.org/onlinepubs/000095399/functions/clock_getres.html
\&  http://linux.die.net/man/3/clock_gettime
.Ve
.PP
Why 'realtime' can appear to go backwards:
.PP
.Vb 1
\&  http://preview.tinyurl.com/5wawnn
.Ve
.PP
The PostgreSQL pg_test_timing utility documentation has a good summary of timing issues:
.PP
.Vb 1
\&  http://www.postgresql.org/docs/9.2/static/pgtesttiming.html
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "\s-1SMP\s0 Systems"
.IX Subsection "SMP Systems"
On systems with multiple processors, which includes most modern machines,
(from Linux docs though applicable to most \s-1SMP\s0 systems):
.PP
.Vb 4
\&  The CLOCK_PROCESS_CPUTIME_ID and CLOCK_THREAD_CPUTIME_ID clocks are realized on
\&  many platforms using timers from the CPUs (TSC on i386, AR.ITC on Itanium).
\&  These registers may differ between CPUs and as a consequence these clocks may
\&  return bogus results if a process is migrated to another CPU.
\&
\&  If the CPUs in an SMP system have different clock sources then there is no way
\&  to maintain a correlation between the timer registers since each CPU will run
\&  at a slightly different frequency. If that is the case then
\&  clock_getcpuclockid(0) will return ENOENT to signify this condition. The two
\&  clocks will then only be useful if it can be ensured that a process stays on a
\&  certain CPU.
\&
\&  The processors in an SMP system do not start all at exactly the same time and
\&  therefore the timer registers are typically running at an offset. Some
\&  architectures include code that attempts to limit these offsets on bootup.
\&  However, the code cannot guarantee to accurately tune the offsets. Glibc
\&  contains no provisions to deal with these offsets (unlike the Linux Kernel).
\&  Typically these offsets are small and therefore the effects may be negligible
\&  in most cases.
.Ve
.PP
In summary, \s-1SMP\s0 systems are likely to give 'noisy' profiles.
Setting a \*(L"Processor Affinity\*(R" may help.
.PP
\fIProcessor Affinity\fR
.IX Subsection "Processor Affinity"
.PP
Processor affinity is an aspect of task scheduling on \s-1SMP\s0 systems.
\&\*(L"Processor affinity takes advantage of the fact that some remnants of a process
may remain in one processor's state (in particular, in its cache) from the last
time the process ran, and so scheduling it to run on the same processor the
next time could result in the process running more efficiently than if it were
to run on another processor.\*(R" (From http://en.wikipedia.org/wiki/Processor_affinity)
.PP
Setting an explicit processor affinity can avoid the problems described in
\&\*(L"\s-1SMP\s0 Systems\*(R".
.PP
Processor affinity can be set using the \f(CW\*(C`taskset\*(C'\fR command on Linux.
.PP
Note that processor affinity is inherited by child processes, so if the process
you're profiling spawns cpu intensive sub processes then your process will be
impacted by those more than it otherwise would.
.PP
\fIWindows\fR
.IX Subsection "Windows"
.PP
\&\fB\s-1THIS SECTION DOESN\s0'T \s-1MATCH THE CODE\s0\fR
.PP
On Windows NYTProf uses Time::HiRes which uses the windows
\&\fIQueryPerformanceCounter()\fR \s-1API\s0 with some extra logic to adjust for the current
clock speed and try to resync the raw counter to wallclock time every so often
(every 30 seconds or if the timer drifts by more than 0.5 of a seconds).
This extra logic may lead to occasional spurious results.
.PP
(It would be great if someone could contribute a patch to NYTProf to use
\&\fIQueryPerformanceCounter()\fR directly and avoid the overheads and resyncing
behaviour of Time::HiRes.)
.SS "Virtual Machines"
.IX Subsection "Virtual Machines"
I recommend you don't do performance profiling while running in a
virtual machine.  If you do you're likely to find inexplicable spikes
of real-time appearing at unreasonable places in your code. You should pay
less attention to the statement timings and rely more on the subroutine
timings. They will still be noisy but less so than the statement times.
.PP
You could also try using the \f(CW\*(C`clock=N\*(C'\fR option to select a high-resolution
\&\fIcpu-time\fR clock instead of a real-time one. That should be much less
noisy, though you will lose visibility of wait-times due to network
and disk I/O, for example.
.SH "BUGS"
.IX Header "BUGS"
Possibly. All complex software has bugs. Let me know if you find one.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Screenshots of nytprofhtml v2.01 reports can be seen at
<http://timbunce.files.wordpress.com/2008/07/nytprof\-perlcritic\-index.png> and
<http://timbunce.files.wordpress.com/2008/07/nytprof\-perlcritic\-all\-perl\-files.png>.
A writeup of the new features of NYTProf v2 can be found at
<http://blog.timbunce.org/2008/07/15/nytprof\-v2\-a\-major\-advance\-in\-perl\-profilers/>
and the background story, explaining the \*(L"why\*(R", can be found at
<http://blog.timbunce.org/2008/07/16/nytprof\-v2\-the\-background\-story/>.
.PP
Mailing list and discussion at <http://groups.google.com/group/develnytprof\-dev>
.PP
Blog posts <http://blog.timbunce.org/tag/nytprof/>
.PP
Public \s-1SVN\s0 Repository and hacking instructions at <http://code.google.com/p/perl\-devel\-nytprof/>
.PP
nytprofhtml is a script included that produces html reports.
nytprofcsv is another script included that produces plain text \s-1CSV\s0 reports.
.PP
Devel::NYTProf::Reader is the module that powers the report scripts.  You
might want to check this out if you plan to implement a custom report (though
it's very likely to be deprecated in a future release).
.PP
Devel::NYTProf::ReadStream is the module that lets you read a profile data
file as a stream of chunks of data.
.PP
Other tools:
.PP
DTrace <https://speakerdeck.com/mrallen1/perl\-dtrace\-and\-you>
.SH "TROUBLESHOOTING"
.IX Header "TROUBLESHOOTING"
.ie n .SS """Profile data incomplete, ..."" or ""Profile format error: ..."""
.el .SS "``Profile data incomplete, ...'' or ``Profile format error: ...''"
.IX Subsection "Profile data incomplete, ... or Profile format error: ..."
This error message means the file doesn't contain all the expected data
or the data has been corrupted in some way.
That may be because it was truncated (perhaps the filesystem was full) or,
more commonly, because the all the expected data hasn't been written.
.PP
NYTProf writes some important data to the data file when \fIfinishing\fR profiling.
If you read the file before the profiling has finished you'll get this error.
.PP
If the process being profiled is still running you'll need to wait until it
exits cleanly (runs \f(CW\*(C`END\*(C'\fR blocks or \*(L"finish_profile\*(R" is called explicitly).
.PP
If the process being profiled has exited then it's likely that it met with a
sudden and unnatural death that didn't give NYTProf a chance to finish the
profile.  If the sudden death was due to a signal, like \s-1SIGTERM,\s0 or a \s-1SIGINT\s0
from pressing Ctrl-C, then the \*(L"sigexit=1\*(R" option may help.
.PP
If the sudden death was due to calling \f(CW\*(C`POSIX::_exit($status)\*(C'\fR then you'll
need to call \*(L"finish_profile\*(R" before calling \f(CW\*(C`POSIX::_exit\*(C'\fR.
.PP
You'll also get this error if the code trying to read the profile is itself
being profiled. That's most likely to happen if you enable profiling via the
\&\f(CW\*(C`PERL5OPT\*(C'\fR environment variable and have forgotten to unset it.
.PP
If you've encountered this error message, and you're sure you've understood the
concerns described above, and you're sure they don't apply in your case, then
please open an issue.  Be sure to include sufficient information so I can see
how you've addressed these likely causes.
.SS "Some source files don't have profile information"
.IX Subsection "Some source files don't have profile information"
This is usually due to NYTProf being initialized after some perl files have
already been compiled.
.PP
If you can't alter the command line to add "\f(CW\*(C`\-d:NYTProf\*(C'\fR" you could try using
the \f(CW\*(C`PERL5OPT\*(C'\fR environment variable. See \*(L"\s-1PROFILING\*(R"\s0.
.PP
You could also try using the \*(L"use_db_sub=1\*(R" option.
.SS "Eval ... has unknown invoking fid"
.IX Subsection "Eval ... has unknown invoking fid"
When using the statement profiler you may see a warning message like this:
.PP
.Vb 1
\&  Eval \*(Aq(eval 2)\*(Aq (fid 9, flags:viastmt,savesrc) has unknown invoking fid 10
.Ve
.PP
Notice that the eval file id (fid 9 in this case) is lower than the file id
that invoked the eval (fid 10 in this case). This is a known problem caused by
the way perl works and how the profiler assigns and outputs the file ids.
The invoking fid is known but gets assigned a fid and output after the fid for
the eval, and that causes the warning when the file is read.
.ie n .SS "Warning: %d subroutine calls had negative time"
.el .SS "Warning: \f(CW%d\fP subroutine calls had negative time"
.IX Subsection "Warning: %d subroutine calls had negative time"
There are two likely causes for this: clock instability, or accumulated timing
errors.
.PP
Clock instability, if present on your system, is most likely to be noticeable on
very small/fast subroutines that are called very few times.
.PP
Accumulated timing errors can arise because the subroutine profiler uses
floating point values (NVs) to store the times.  They are most likely to be
noticed on subroutines that are called a few times but which make a large
number of calls to very fast subroutines (such as opcodes). In this case the
accumulated time apparently spent making those calls can be greater than the
time spent in the calling subroutine.
.PP
If you rerun nytprofhtml (etc.) with the \*(L"trace=N\*(R" option set >0 you'll see
trace messages like  \*(L"%s call has negative time: incl \f(CW%fs\fR, excl \f(CW%fs\fR\*(R" for each
affected subroutine.
.PP
Try profiling with the \*(L"slowops=N\*(R" option set to 0 to disable the profiling
of opcodes. Since opcodes often execute in a few microseconds they are a common
cause of this warning.
.PP
You could also try recompiling perl to use 'long doubles' for the \s-1NV\s0 floating
point type (use Configure \-Duselongdouble). If you try this please let me know.
I'd also happily take a patch to use long doubles, if available, by default.
.SS "panic: buffer overflow ..."
.IX Subsection "panic: buffer overflow ..."
You have unusually long subroutine names in your code. You'll need to rebuild
Devel::NYTProf with the \s-1NYTP_MAX_SUB_NAME_LEN\s0 environment variable set to a
value longer than the longest subroutine names in your code.
.SH "AUTHORS AND CONTRIBUTORS"
.IX Header "AUTHORS AND CONTRIBUTORS"
\&\fBTim Bunce\fR (<http://www.tim.bunce.name> and <http://blog.timbunce.org>)
leads the project and has done most of the development work thus far.
.PP
\&\fBNicholas Clark\fR contributed zip compression and \f(CW\*(C`nytprofmerge\*(C'\fR.
\&\fBChia-liang Kao\fR contributed \f(CW\*(C`nytprofcg\*(C'\fR.
\&\fBPeter (Stig) Edwards\fR contributed the \s-1VMS\s0 port.
\&\fBJan Dubois\fR contributed the Windows port.
\&\fBGisle Aas\fR contributed the Devel::NYTProf::ReadStream module.
\&\fBSteve Peters\fR contributed greater perl version portability and use of \s-1POSIX\s0
high-resolution clocks.
Other contributors are noted in the Changes file.
.PP
Many thanks to \fBAdam Kaplan\fR who created \f(CW\*(C`NYTProf\*(C'\fR initially by forking
\&\f(CW\*(C`Devel::FastProf\*(C'\fR adding reporting from \f(CW\*(C`Devel::Cover\*(C'\fR and a test suite.
For more details see \*(L"\s-1HISTORY\*(R"\s0 below.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 2
\&  Copyright (C) 2008 by Adam Kaplan and The New York Times Company.
\&  Copyright (C) 2008\-2016 by Tim Bunce, Ireland.
.Ve
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.8 or,
at your option, any later version of Perl 5 you may have available.
.SS "Background"
.IX Subsection "Background"
Subroutine-level profilers:
.PP
.Vb 6
\&  Devel::DProf        | 1995\-10\-31 | ILYAZ
\&  Devel::AutoProfiler | 2002\-04\-07 | GSLONDON
\&  Devel::Profiler     | 2002\-05\-20 | SAMTREGAR
\&  Devel::Profile      | 2003\-04\-13 | JAW
\&  Devel::DProfLB      | 2006\-05\-11 | JAW
\&  Devel::WxProf       | 2008\-04\-14 | MKUTTER
.Ve
.PP
Statement-level profilers:
.PP
.Vb 4
\&  Devel::SmallProf    | 1997\-07\-30 | ASHTED
\&  Devel::FastProf     | 2005\-09\-20 | SALVA
\&  Devel::NYTProf      | 2008\-03\-04 | AKAPLAN
\&  Devel::Profit       | 2008\-05\-19 | LBROCARD
.Ve
.PP
Devel::NYTProf is a (now distant) fork of Devel::FastProf, which was itself an
evolution of Devel::SmallProf.
.PP
Adam Kaplan forked Devel::FastProf and added html report generation (based on
Devel::Cover) and a test suite \- a tricky thing to do for a profiler.
Meanwhile Tim Bunce had been extending Devel::FastProf to add novel
per-sub and per-block timing, plus subroutine caller tracking.
.PP
When Devel::NYTProf was released Tim switched to working on Devel::NYTProf
because the html report would be a good way to show the extra profile data, and
the test suite made development much easier and safer.
.PP
Then Tim went a little crazy and added a slew of new features, in addition to
per-sub and per-block timing and subroutine caller tracking. These included the
\&'opcode interception' method of profiling, ultra-fast and robust inclusive
subroutine timing, doubling performance, plus major changes to html reporting
to display all the extra profile call and timing data in richly annotated and
cross-linked reports.
.PP
Steve Peters came on board along the way with patches for portability and to
keep NYTProf working with the latest development perl versions. Nicholas Clark
added zip compression, many optimizations, and \f(CW\*(C`nytprofmerge\*(C'\fR.
Jan Dubois contributed Windows support.
.PP
Adam's work was sponsored by The New York Times Co. <http://open.nytimes.com>.
Tim's work was partly sponsored by Shopzilla <http://www.shopzilla.com> during 2008
but hasn't been sponsored since then.
.PP
For the record, Tim has never worked for the New York Times nor has he received any
kind of sponsorship or support from them in relation to NYTProf. The name of
this module is simply result of the history outlined above, which can be
summarised as: Adam forked an existing module when he added his enhancements
and Tim didn't.
